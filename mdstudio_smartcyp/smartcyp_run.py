# -*- coding: utf-8 -*-

"""
file: smartcyp_run.py

Defines the SmartCypRunner class responsible for running the SMARTCyp
Java code and parsing the output to structured JSON.
"""

import subprocess
import tempfile
import glob
import csv
import os
import shutil
import logging
import base64

from mdstudio_smartcyp import __smartcyp_path__, __module__

logger = logging.getLogger(__module__)
result_types = {'Ranking': int, '2DSASA': float, 'N+Dist': int, '2D6ranking': int, 'Energy': float,
                'Molecule': int, 'Span2End': int, 'Score': float, 'Relative Span': float,
                '2Cscore': float, 'Atom': str, '2Cranking': int, 'COODist': int, '2D6score': float}


class SmartCypRunner(object):
    """
    SmartCypRunner class

    Responsible for running the SMARTCyp Java code and parsing the output
    to structured JSON.
    """

    def __init__(self, log=logger):

        self.log = log

        # Make a temporary directory
        self.tempdir = tempfile.mkdtemp()
        self.log.debug('Make temporary directory at: {0}'.format(self.tempdir))

    def _parse_csv(self, csvfile):
        """
        Parse SMARTCyp results .csv file

        Returns a JSON style dictionary with CSV rows keyed by atom identifier.
        Rows are keyed by the .csv header name. Values are coursed to their
        appropriate type with 'null' values to python None.

        :param csvfile: CSV file name
        :type csvfile:  :py:dict

        :return:        content of .csv file as dictionary
        :rtype:         :py:dict
        """

        csv_rows = {}
        reader = csv.DictReader(csvfile)
        title = reader.fieldnames
        for row in reader:
            drow = {title[i]: row[title[i]] for i in range(len(title))}

            # Type convert
            for key, value in drow.items():
                if not key in result_types:
                    self.log.warning('Unknown results parameter: {0}'.format(key))

                convert_to = result_types[key]
                try:
                    # 'null' to None
                    if value == 'null':
                        drow[key] = None
                    else:
                        drow[key] = convert_to(value)
                except ValueError:
                    self.log.warning('Unable to convert {0}: {1} to {2}'.format(key, value, convert_to))

            csv_rows[drow['Atom']] = drow

        return csv_rows

    def _parse_images(self):
        """
        Parse PNG image files generated by SMARTCyp and encode using base64

        :rtype: :py:dict
        """

        image_results = {}
        for output in glob.glob('{0}/*'.format(self.tempdir)):
            if os.path.isdir(output) and 'smartcyp_images' in output:

                for image in glob.glob('{0}/*.png'.format(output)):
                    image_name = os.path.basename(image).split('.')[0]

                    with open(image, "rb") as image_file:
                        image_results[image_name] = base64.b64encode(image_file.read())

        return image_results

    def run(self, mol, is_smiles=False, output_format='json', noempcorr=False, output_png=False):
        """
        Run SMARTCyp predictions

        Runs a SMARTCyp prediction for molecule `mol` in a system temporary
        directory and returns the content of the prediction .csv file as
        a dictionary.

        :param mol:         molecule to make prediction for
        :type mol:          :py:str
        :param is_smiles:   is the molecule a SMILES string
        :type is_smiles:    :py:bool

        :return:            SMARTCyp prediction results
        :rtype:             :py:dict
        """

        # Build CMD
        cmd = ['java', '-jar', __smartcyp_path__, '-printall']
        if noempcorr:
            cmd.append('-noempcorr')

        if output_png:
            cmd.append('-png')

        if is_smiles:
            cmd.extend(['-smiles', mol])
            self.log.info('SMARTCyp prediction for SMILES string: {0}'.format(mol))

        else:
            with open('{0}/ligand.mol2'.format(self.tempdir), 'w') as ligfile:
                ligfile.write(mol)

            cmd.append(os.path.join(self.tempdir, 'ligand.mol2'))

        # Run SMARTCyp
        cmd.extend(['-outputdir', self.tempdir])
        self.log.debug('SMARTCyp CMD: {0}'.format(' '.join(cmd)))

        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()

        if process.returncode != 0:
            self.log.warning('SMARTCyp run with non-zero exit code ({0}): {1}'.format(process.returncode, err))

        result = {'result': None}
        if output_format in ('csv', 'json'):

            # Get output CSV
            csvfile = glob.glob('{0}/*.csv'.format(self.tempdir))
            if len(csvfile):
                with open(csvfile[0], 'r') as csvfile:
                    if output_format == 'csv':
                        result['result'] = csvfile.read()
                    elif output_format == 'json':
                        result['result'] = self._parse_csv(csvfile)
            else:
                self.log.error('SMARTCyp did not create a results .csv file')

        else:

            # Get output HTML
            htmlfile = glob.glob('{0}/*.html'.format(self.tempdir))
            if len(htmlfile):
                with open(htmlfile[0], 'r') as html:
                    result['result'] = html.read()
            else:
                self.log.error('SMARTCyp did not create a results .html file')

        if output_png:
            image_results = self._parse_images()
            result.update(image_results)

        # Remove the temporary directory again
        self.log.debug('Remove temporary directory: {0}'.format(self.tempdir))
        shutil.rmtree(self.tempdir)

        return result
