# -*- coding: utf-8 -*-

"""
file: smartcyp_run.py

Defines the SmartCypRunner class responsible for running the SMARTCyp
Java code and parsing the output to structured JSON.
"""

import glob
import pandas
import os
import logging
import base64

from mdstudio_smartcyp import (__smartcyp_version__, __smartcyp_citation__, __supported_models__, __smartcyp_path__,
                               __module__)
from mdstudio_smartcyp.utils import prepare_work_dir, RunnerBaseClass, renumber_smartcyp_atoms

logger = logging.getLogger(__module__)


def smartcyp_version_info():
    """
    :return: information on the packaged SMARTCyp version, supported models
             and software citation reference.
    :rtype:  :py:dict
    """

    info_dict = {'version': __smartcyp_version__,
                 'models': __supported_models__,
                 'citation': __smartcyp_citation__}

    return info_dict


class SmartCypRunner(RunnerBaseClass):
    """
    SmartCypRunner class

    Responsible for running the SMARTCyp Java code and parsing the output
    to structured JSON.
    """

    def __init__(self, log=logger, base_work_dir=None):
        """
        Implement class __init__

        :param log:           external logger instance
        :type log:            :py:logging
        :param base_work_dir: base directory for unique docking results dirs.
        :type base_work_dir:  :py:str
        """

        self.log = log

        # Make a temporary directory
        self.workdir = prepare_work_dir(path=base_work_dir, prefix='smartcyp-')
        self.results = None

    def _parse_csv(self, csvfile, ligfile=None):
        """
        Parse SMARTCyp results .csv file

        Returns a JSON style dictionary with CSV rows keyed by atom identifier.
        Rows are keyed by the .csv header name. Values are coursed to their
        appropriate type with 'null' values to python None.

        :param csvfile: CSV file name
        :type csvfile:  :py:dict

        :return:        content of .csv file as dictionary
        :rtype:         :py:dict
        """

        results = pandas.read_csv(csvfile, index_col='Atom')
        results['Atom_id'] = [int(i.split('.')[-1]) for i in results.index]

        if ligfile:
            results = renumber_smartcyp_atoms(ligfile, results)

        self.results = results.where((pandas.notnull(results)), None)

    def _parse_html(self, htmlfile):
        """
        Parse SMARTCyp results .html file

        Strip the SMARTCyp header text from the HTML for a cleaner output

        :param htmlfile:    path to HTML file to parse
        :type htmlfile:     :py:str

        :return:            cleaned content of HTML file
        :rtype:             :py:str
        """

        cleaned = []
        with open(htmlfile) as html:

            skip = False
            for line in html.readlines():

                if line.startswith('<!--'):
                    skip = False

                if skip:
                    continue

                if line.startswith('<body>'):
                    skip = True

                cleaned.append(line)

        return ''.join(cleaned)

    def _parse_images(self):
        """
        Parse PNG image files generated by SMARTCyp and encode using base64

        :rtype: :py:dict
        """

        image_results = {}
        for output in glob.glob('{0}/*'.format(self.workdir)):
            if os.path.isdir(output) and 'smartcyp_images' in output:

                for image in glob.glob('{0}/*.png'.format(output)):
                    image_name = os.path.basename(image).split('.')[0]

                    with open(image, "rb") as image_file:
                        base64_image = base64.b64encode(image_file.read())
                        image_results[image_name] = base64_image.decode('ascii')

        return image_results

    def run(self, mol, is_smiles=False, input_format='mol2', output_format='json', noempcorr=False, output_png=False):
        """
        Run SMARTCyp predictions

        Runs a SMARTCyp prediction for molecule `mol` in a system temporary
        directory and returns the content of the prediction .csv file as
        a dictionary.

        :param mol:           molecule to make prediction for
        :type mol:            :py:str
        :param is_smiles:     is the molecule a SMILES string
        :type is_smiles:      :py:bool
        :param output_format: output format as CSV, JSON or HTML
        :type output_format:  :py:str
        :param noempcorr:     do not use the empirical N-oxidation correction
                              (smartcyp >= v2.3)
        :type noempcorr:      :py:bool
        :param output_png:    export PNG image files for the prediction

        :return:              SMARTCyp prediction results
        :rtype:               :py:dict
        """

        # Build CMD
        cmd = ['java', '-jar', __smartcyp_path__, '-printall']
        if noempcorr:
            cmd.append('-noempcorr')

        if output_png:
            cmd.append('-png')

        if is_smiles:
            cmd.extend(['-smiles', mol])
            self.log.info('SMARTCyp prediction for SMILES string: {0}'.format(mol))

        else:
            with open('{0}/ligand.{1}'.format(self.workdir, input_format), 'w') as ligfile:
                ligfile.write(mol)

            cmd.append(os.path.join(self.workdir, 'ligand.mol2'))

        # Run SMARTCyp
        result = {'result': None}
        if self.cmd_runner(cmd):

            csvfile = glob.glob('{0}/*.csv'.format(self.workdir))
            if len(csvfile):

                if input_format in ('mol2', 'mol'):
                    self._parse_csv(csvfile[0], ligfile=mol)
                else:
                    self._parse_csv(csvfile[0])

                if output_format == 'csv':
                    result['result'] = self.results.to_csv()
                elif output_format == 'json':
                    self.results['Atom'] = self.results.index
                    result['result'] = self.results.to_dict(orient='index')
            else:
                self.log.error('SMARTCyp did not create a results .csv file')

            if output_format == 'html':
                # Get output HTML
                htmlfile = glob.glob('{0}/*.html'.format(self.workdir))
                if len(htmlfile):
                    result['result'] = self._parse_html(htmlfile[0])
                else:
                    self.log.error('SMARTCyp did not create a results .html file')

            if output_png:
                image_results = self._parse_images()
                result['images'] = image_results

        else:
            self.log.error('Failed to run SMARTCyp')

        return result
