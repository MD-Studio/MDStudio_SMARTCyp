# -*- coding: utf-8 -*-

"""
file: smartcyp_run.py

Defines the SmartCypRunner class responsible for running the SMARTCyp
Java code and parsing the output to structured JSON.
"""

import glob
import csv
import os
import logging
import base64

from mdstudio_smartcyp import (__smartcyp_version__, __smartcyp_citation__, __supported_models__, __smartcyp_path__,
                               __module__)
from mdstudio_smartcyp.utils import prepare_work_dir, RunnerBaseClass

logger = logging.getLogger(__module__)
result_types = {'Ranking': int, '2DSASA': float, 'N+Dist': int, '2D6ranking': int, 'Energy': float,
                'Molecule': int, 'Span2End': int, 'Score': float, 'Relative Span': float,
                '2Cscore': float, 'Atom': str, '2Cranking': int, 'COODist': int, '2D6score': float}


def smartcyp_version_info():
    """
    :return: information on the packaged SMARTCyp version, supported models
             and software citation reference.
    :rtype:  :py:dict
    """

    info_dict = {'version': __smartcyp_version__,
                 'models': __supported_models__,
                 'citation': __smartcyp_citation__}

    return info_dict


class SmartCypRunner(RunnerBaseClass):
    """
    SmartCypRunner class

    Responsible for running the SMARTCyp Java code and parsing the output
    to structured JSON.
    """

    def __init__(self, log=logger, workdir=None):
        """
        Implement class __init__

        :param log:     external logger instance
        :param workdir: path to base working directory
        :type workdir:  :py:str
        """

        self.log = log

        # Make a temporary directory
        self.workdir = prepare_work_dir(path=workdir, prefix='smartcyp-')

    def _parse_csv(self, csvfile):
        """
        Parse SMARTCyp results .csv file

        Returns a JSON style dictionary with CSV rows keyed by atom identifier.
        Rows are keyed by the .csv header name. Values are coursed to their
        appropriate type with 'null' values to python None.

        :param csvfile: CSV file name
        :type csvfile:  :py:dict

        :return:        content of .csv file as dictionary
        :rtype:         :py:dict
        """

        csv_rows = {}
        reader = csv.DictReader(csvfile)
        title = reader.fieldnames
        for row in reader:
            drow = {title[i]: row[title[i]] for i in range(len(title))}

            # Type convert
            for key, value in drow.items():
                if not key in result_types:
                    self.log.warning('Unknown results parameter: {0}'.format(key))

                convert_to = result_types[key]
                try:
                    # 'null' to None
                    if value == 'null':
                        drow[key] = None
                    else:
                        drow[key] = convert_to(value)
                except ValueError:
                    self.log.warning('Unable to convert {0}: {1} to {2}'.format(key, value, convert_to))

            csv_rows[drow['Atom']] = drow

        return csv_rows

    def _parse_html(self, htmlfile):
        """
        Parse SMARTCyp results .html file

        Strip the SMARTCyp header text from the HTML for a cleaner output

        :param htmlfile:    path to HTML file to parse
        :type htmlfile:     :py:str

        :return:            cleaned content of HTML file
        :rtype:             :py:str
        """

        cleaned = []
        with open(htmlfile) as html:

            skip = False
            for line in html.readlines():

                if line.startswith('<!--'):
                    skip = False

                if skip:
                    continue

                if line.startswith('<body>'):
                    skip = True

                cleaned.append(line)

        return ''.join(cleaned)

    def _parse_images(self):
        """
        Parse PNG image files generated by SMARTCyp and encode using base64

        :rtype: :py:dict
        """

        image_results = {}
        for output in glob.glob('{0}/*'.format(self.workdir)):
            if os.path.isdir(output) and 'smartcyp_images' in output:

                for image in glob.glob('{0}/*.png'.format(output)):
                    image_name = os.path.basename(image).split('.')[0]

                    with open(image, "rb") as image_file:
                        base64_image = base64.b64encode(image_file.read())
                        image_results[image_name] = base64_image.decode('ascii')

        return image_results

    def run(self, mol, is_smiles=False, output_format='json', noempcorr=False, output_png=False):
        """
        Run SMARTCyp predictions

        Runs a SMARTCyp prediction for molecule `mol` in a system temporary
        directory and returns the content of the prediction .csv file as
        a dictionary.

        :param mol:           molecule to make prediction for
        :type mol:            :py:str
        :param is_smiles:     is the molecule a SMILES string
        :type is_smiles:      :py:bool
        :param output_format: output format as CSV, JSON or HTML
        :type output_format:  :py:str
        :param noempcorr:     do not use the empirical N-oxidation correction
                              (smartcyp >= v2.3)
        :type noempcorr:      :py:bool
        :param output_png:    export PNG image files for the prediction

        :return:              SMARTCyp prediction results
        :rtype:               :py:dict
        """

        # Build CMD
        cmd = ['java', '-jar', __smartcyp_path__, '-printall']
        if noempcorr:
            cmd.append('-noempcorr')

        if output_png:
            cmd.append('-png')

        if is_smiles:
            cmd.extend(['-smiles', mol])
            self.log.info('SMARTCyp prediction for SMILES string: {0}'.format(mol))

        else:
            with open('{0}/ligand.mol2'.format(self.workdir), 'w') as ligfile:
                ligfile.write(mol)

            cmd.append(os.path.join(self.workdir, 'ligand.mol2'))

        # Run SMARTCyp
        self.cmd_runner(cmd)

        result = {'result': None}
        if output_format in ('csv', 'json'):

            # Get output CSV
            csvfile = glob.glob('{0}/*.csv'.format(self.workdir))
            if len(csvfile):
                with open(csvfile[0], 'r') as csvfile:
                    if output_format == 'csv':
                        result['result'] = csvfile.read()
                    elif output_format == 'json':
                        result['result'] = self._parse_csv(csvfile)
            else:
                self.log.error('SMARTCyp did not create a results .csv file')

        else:

            # Get output HTML
            htmlfile = glob.glob('{0}/*.html'.format(self.workdir))
            if len(htmlfile):
                result['result'] = self._parse_html(htmlfile[0])
            else:
                self.log.error('SMARTCyp did not create a results .html file')

        if output_png:
            image_results = self._parse_images()
            result['images'] = image_results

        return result
