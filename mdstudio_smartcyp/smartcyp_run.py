# -*- coding: utf-8 -*-

"""
file: smartcyp_run.py

Defines the SmartCypRunner class responsible for running the SMARTCyp
Java code and parsing the output to structured JSON.
"""

import subprocess
import tempfile
import glob
import csv
import os
import re
import shutil
import logging
import base64

from mdstudio_smartcyp import (__smartcyp_version__, __smartcyp_citation__, __supported_models__, __smartcyp_path__,
                               __module__)

logger = logging.getLogger(__module__)
smiles_regex = re.compile('^([^J][A-Za-z0-9@+\-\[\]\(\)\\\/%=#$]+)$')
result_types = {'Ranking': int, '2DSASA': float, 'N+Dist': int, '2D6ranking': int, 'Energy': float,
                'Molecule': int, 'Span2End': int, 'Score': float, 'Relative Span': float,
                '2Cscore': float, 'Atom': str, '2Cranking': int, 'COODist': int, '2D6score': float}


def mol_validate_file_object(path_file):
    """
    Validate a MDStudio/REST path_file object

    - Check if 'content' is a InChI or SMILES string and set extension
    - If no 'content' check if path exists and import file

    :param path_file: path_file object
    :type path_file:  :py:dict

    :return:          validated path_file object
    :rtype:           :py:dict
    """

    content = path_file['content']
    if content is not None:

        # SMILES and InChI are single line strings
        if len(content.split('\n')) == 1:

            # Test for InChI type
            if content.startswith('InChI='):
                path_file['extension'] = 'inchi'

            # Test for SMILES
            if smiles_regex.match(path_file['content']):
                path_file['extension'] = 'smi'

    elif path_file['path'] is not None and os.path.exists(path_file['path']):

        with open(path_file['path']) as pf:
            path_file['content'] = pf.read()

    return path_file


def smartcyp_version_info():
    """
    :return: information on the packaged SMARTCyp version, supported models
             and software citation reference.
    :rtype:  :py:dict
    """

    info_dict = {'version': __smartcyp_version__,
                 'models': __supported_models__,
                 'citation': __smartcyp_citation__}

    return info_dict


class SmartCypRunner(object):
    """
    SmartCypRunner class

    Responsible for running the SMARTCyp Java code and parsing the output
    to structured JSON.
    """

    def __init__(self, log=logger):

        self.log = log

        # Make a temporary directory
        self.tempdir = tempfile.mkdtemp()
        self.log.debug('Make temporary directory at: {0}'.format(self.tempdir))

    def _parse_csv(self, csvfile):
        """
        Parse SMARTCyp results .csv file

        Returns a JSON style dictionary with CSV rows keyed by atom identifier.
        Rows are keyed by the .csv header name. Values are coursed to their
        appropriate type with 'null' values to python None.

        :param csvfile: CSV file name
        :type csvfile:  :py:dict

        :return:        content of .csv file as dictionary
        :rtype:         :py:dict
        """

        csv_rows = {}
        reader = csv.DictReader(csvfile)
        title = reader.fieldnames
        for row in reader:
            drow = {title[i]: row[title[i]] for i in range(len(title))}

            # Type convert
            for key, value in drow.items():
                if not key in result_types:
                    self.log.warning('Unknown results parameter: {0}'.format(key))

                convert_to = result_types[key]
                try:
                    # 'null' to None
                    if value == 'null':
                        drow[key] = None
                    else:
                        drow[key] = convert_to(value)
                except ValueError:
                    self.log.warning('Unable to convert {0}: {1} to {2}'.format(key, value, convert_to))

            csv_rows[drow['Atom']] = drow

        return csv_rows

    def _parse_images(self):
        """
        Parse PNG image files generated by SMARTCyp and encode using base64

        :rtype: :py:dict
        """

        image_results = {}
        for output in glob.glob('{0}/*'.format(self.tempdir)):
            if os.path.isdir(output) and 'smartcyp_images' in output:

                for image in glob.glob('{0}/*.png'.format(output)):
                    image_name = os.path.basename(image).split('.')[0]

                    with open(image, "rb") as image_file:
                        base64_image = base64.b64encode(image_file.read())
                        image_results[image_name] = base64_image.decode('ascii')

        return image_results

    def run(self, mol, is_smiles=False, output_format='json', noempcorr=False, output_png=False):
        """
        Run SMARTCyp predictions

        Runs a SMARTCyp prediction for molecule `mol` in a system temporary
        directory and returns the content of the prediction .csv file as
        a dictionary.

        :param mol:           molecule to make prediction for
        :type mol:            :py:str
        :param is_smiles:     is the molecule a SMILES string
        :type is_smiles:      :py:bool
        :param output_format: output format as CSV, JSON or HTML
        :type output_format:  :py:str
        :param noempcorr:     do not use the empirical N-oxidation correction
                              (smartcyp >= v2.3)
        :type noempcorr:      :py:bool
        :param output_png:    export PNG image files for the prediction

        :return:              SMARTCyp prediction results
        :rtype:               :py:dict
        """

        # Build CMD
        cmd = ['java', '-jar', __smartcyp_path__, '-printall']
        if noempcorr:
            cmd.append('-noempcorr')

        if output_png:
            cmd.append('-png')

        if is_smiles:
            cmd.extend(['-smiles', mol])
            self.log.info('SMARTCyp prediction for SMILES string: {0}'.format(mol))

        else:
            with open('{0}/ligand.mol2'.format(self.tempdir), 'w') as ligfile:
                ligfile.write(mol)

            cmd.append(os.path.join(self.tempdir, 'ligand.mol2'))

        # Run SMARTCyp
        cmd.extend(['-outputdir', self.tempdir])
        self.log.info('Run SMARTCyp: {0}'.format(' '.join(cmd)))

        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()

        if process.returncode != 0:
            self.log.warning('SMARTCyp run with non-zero exit code ({0}): {1}'.format(process.returncode, err))

        result = {'result': None}
        if output_format in ('csv', 'json'):

            # Get output CSV
            csvfile = glob.glob('{0}/*.csv'.format(self.tempdir))
            if len(csvfile):
                with open(csvfile[0], 'r') as csvfile:
                    if output_format == 'csv':
                        result['result'] = csvfile.read()
                    elif output_format == 'json':
                        result['result'] = self._parse_csv(csvfile)
            else:
                self.log.error('SMARTCyp did not create a results .csv file')

        else:

            # Get output HTML
            htmlfile = glob.glob('{0}/*.html'.format(self.tempdir))
            if len(htmlfile):
                with open(htmlfile[0], 'r') as html:
                    result['result'] = html.read()
            else:
                self.log.error('SMARTCyp did not create a results .html file')

        if output_png:
            image_results = self._parse_images()
            result['images'] = image_results

        # Remove the temporary directory again
        self.log.debug('Remove temporary directory: {0}'.format(self.tempdir))
        shutil.rmtree(self.tempdir)

        return result
